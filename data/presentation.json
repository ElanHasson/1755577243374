{
  "metadata": {
    "title": "F# for Normal People",
    "description": "Curious about functional programming but not sure where to start? This webinar introduces F# in plain, practical terms—no math degree required. You’ll learn how F# makes everyday coding tasks simpler, how it plays nicely with .NET, and why you don’t need to be a functional programming expert to use it effectively.",
    "author": "Webinar Maker Pro",
    "domain": "technical",
    "duration": 10,
    "created": "2025-08-19T04:11:31.244Z",
    "version": "1.0.0",
    "language": "en-US",
    "theme": {
      "primaryColor": "#2563eb",
      "secondaryColor": "#1e40af",
      "fontFamily": "Inter, system-ui, sans-serif",
      "codeTheme": "github"
    }
  },
  "slides": [
    {
      "id": "s1",
      "content": {
        "type": "title",
        "title": "Why F# Fits Everyday .NET Work: simpler code, fewer bugs, same ecosystem",
        "subtitle": "An AI-Generated Presentation",
        "presenter": "Webinar Maker Pro",
        "date": "2025-08-19"
      },
      "speakerNotes": "0:00–0:10: Welcome. Set context: this is for everyday .NET devs curious about FP without theory overhead.\n0:10–0:25: Emphasize “same .NET” point. Call out tooling and deployment parity.\n0:25–0:45: Hit “simpler code”: inference, records, pipes. Keep it concrete; avoid jargon.\n0:45–1:05: “Fewer bugs”: immutability, DUs, Option/Result, pattern matching, compiler exhaustiveness.\n1:05–1:20: Walk through the short code example. Point out how invalid states are prevented and how the pipe reads top-to-bottom.\n1:20–1:30: Show the Mermaid interoperability diagram. Reinforce interop with ASP.NET Core, HttpClient, System.Text.Json.\n1:30–1:35: Tease upcoming demos: modeling, data pipeline, async with task.\nStage directions:\n- Advance to slide; briefly zoom the code block while describing.\n- Pause 2–3 seconds after the “fewer bugs” line to let it land.\n- If time allows, ask: “How many of you fight nulls and exceptions daily?” (quick show of hands).\n- Technical: Ensure editor font size is readable; terminal ready for later demos.\n- Keep language simple; avoid FP jargon unless explained.",
      "narration": "If you’re curious about functional programming but not sure where to start, this is for you... F# is a practical way to write everyday .NET code with less ceremony and fewer bugs—no math degree required... The best part is, it’s still just .NET... You use the same runtime, the same libraries, the same tooling in Visual Studio or VS Code, and you deploy the same way to containers or the cloud.\nWhat makes F# feel simpler is its defaults... The compiler infers types, so you write less boilerplate while keeping strong typing... Records give you lightweight, immutable data... And the pipe operator lets you read code top to bottom like a recipe.\nIt also helps you avoid entire classes of bugs... Immutability reduces surprises... Discriminated unions let you model real business cases, and Option and Result make nulls and unchecked exceptions explicit... Pattern matching guides you to handle every case, so the compiler becomes your teammate.\nOn screen is a tiny example: we model Email and a Registration workflow so that invalid states—like confirming something twice—are caught in code, not at runtime... And a simple file word count shows how pipelines make everyday data tasks clear.\nFinally, interop is seamless... Your C# and F# code can call each other, use HttpClient or ASP.NET Core, and return Task for async... In the next sections, I’ll show how to model domains, transform data, and do async in a few focused demos.",
      "duration": 1.5,
      "transition": "fade",
      "componentPath": "./components/slides/Slide_s1.tsx",
      "audioPath": "/audio/slide-s1.mp3"
    },
    {
      "id": "s2",
      "content": {
        "type": "markdown",
        "title": "Core ideas in plain English: immutability, type inference, records, unions, pattern matching, options/results, and pipes",
        "markdown": "- Immutability by default: fewer side effects and easier reasoning\n- Strong types without noise: type inference reduces boilerplate\n- Records + Unions: model real cases; make invalid states unrepresentable\n- Pattern matching: handle every case clearly; compiler checks exhaustiveness\n- Option/Result + pipes: replace nulls/exceptions; read code top-to-bottom\n\n```fsharp\ntype Customer = { Id: int; Email: string } // record; immutable, inferred\ntype Payment = | Card of last4:string | Cash // union\n\nlet describe p =\n  match p with\n  | Card last4 -> $\"Card ****{last4}\"\n  | Cash -> \"Cash\"\n\nlet toResult err opt = match opt with Some v -> Ok v | None -> Error err\n\nlet confirm id rawEmail payment =\n  rawEmail\n  |> Option.ofObj               // null -> None\n  |> Option.filter (fun s -> s.Contains \"@\")\n  |> toResult \"Invalid email\"   // Option -> Result\n  |> Result.map (fun email -> { Id = id; Email = email })\n  |> Result.map (fun c -> $\"{c.Id}: {describe payment} to {c.Email}\")\n```\n\n```mermaid\nflowchart LR\n  A[\"rawEmail (possibly null)\"] --> B[\"Option.ofObj\"]\n  B --> C[\"filter contains '@'\"]\n  C --> D[\"toResult 'Invalid email'\"]\n  D -->|Ok| E[\"create record + describe payment\"]\n  D -->|Error| F[\"error message\"]\n```"
      },
      "speakerNotes": "- 0:00–0:05 Briefly say: These are the core ideas you need; no FP PhD required\n- 0:05–0:25 Walk down the bullets: immutability, inference, records + unions, pattern matching\n- 0:25–0:40 Show the code: point out Option.ofObj for null interop, toResult for explicit errors, pattern match in describe, and the |> pipes\n- 0:40–0:45 Reference the flowchart to reinforce the data flow; transition to next demo\n- Technical reminders: Zoom into keywords (type, match, Some/None, Ok/Error, |>). Do not deep-dive syntax; keep it high level. If asked, note this works with any .NET library",
      "narration": "Here are the core F# ideas in plain English... Immutability by default means values do not change unless you choose to, which cuts down on side effects... You still get strong types, but type inference writes the types for you... Records and discriminated unions let you model your domain directly, so many invalid states simply cannot exist... Pattern matching gives you clear, exhaustive handling of each case... Instead of nulls and surprise exceptions, Option and Result make success and failure explicit... And the pipe operator reads top to bottom like a recipe, composing .NET calls cleanly... The small example on screen shows all of these working together.",
      "duration": 0.75,
      "transition": "fade",
      "componentPath": "./components/slides/Slide_s2.tsx",
      "audioPath": "/audio/slide-s2.mp3"
    },
    {
      "id": "s3",
      "content": {
        "type": "markdown",
        "title": "Model real business rules with records, discriminated unions, and Result (registration workflow)",
        "markdown": "**What we’ll model (plain English)**\n- Registration has two states: Pending and Confirmed\n- Emails are validated up front—no nulls, no \"stringly-typed\" bugs\n- Business rules expressed with Result for clear success/failure\n- Pattern matching enforces handling every case\n\n```fsharp\n// Domain errors we expect (no exceptions for control flow)\ntype DomainError =\n  | InvalidEmail\n  | AlreadyConfirmed\n\n// Email as a single-case DU with a safe constructor\ntype Email = private Email of string\nmodule Email =\n  let value (Email e) = e\n  let tryCreate (s: string) : Result<Email, DomainError> =\n    if System.String.IsNullOrWhiteSpace s || not (s.Contains \"@\") then Error InvalidEmail\n    else Ok (Email s)\n\n// Registration lifecycle modeled as a DU\ntype Registration =\n  | Pending of email: Email\n  | Confirmed of email: Email * confirmedAt: System.DateTime\n\nmodule Registration =\n  // Create a Pending registration if the email is valid\n  let register (rawEmail: string) : Result<Registration, DomainError> =\n    rawEmail |> Email.tryCreate |> Result.map Pending\n\n  // Business rule: only Pending can become Confirmed\n  let confirm (now: System.DateTime) (reg: Registration) : Result<Registration, DomainError> =\n    match reg with\n    | Pending e -> Ok (Confirmed (e, now))\n    | Confirmed _ -> Error AlreadyConfirmed\n\n// Example flow\nlet now = System.DateTime.UtcNow\nlet outcome =\n  \"ada@example.com\"\n  |> Registration.register\n  |> Result.bind (Registration.confirm now)\n\nlet message =\n  match outcome with\n  | Ok (Registration.Confirmed (e, at)) -> $\"Confirmed {Email.value e} at {at:O}\"\n  | Error InvalidEmail -> \"Please enter a valid email.\"\n  | Error AlreadyConfirmed -> \"This link was already used.\"\n```\n\n```mermaid\nflowchart TD\n  User[User] --> Enter[\"Enter email\"]\n  Enter --> Validate[\"Email.tryCreate\"]\n  Validate -->|Ok Email| MkPending[\"Registration.Pending\"]\n  Validate -->|Error InvalidEmail| FailInvalid[\"Stop: show validation error\"]\n  MkPending --> Click[\"Confirm link clicked\"]\n  Click --> Confirm[\"Registration.confirm\"]\n  Confirm -->|Ok Confirmed| Done[\"Registration.Confirmed\"]\n  Confirm -->|Error AlreadyConfirmed| FailAlready[\"Stop: already confirmed\"]\n```\n\n**Why this helps in .NET apps**\n- Invalid states are unrepresentable; fewer runtime bugs\n- Clear, compiler-checked errors with Result instead of exceptions\n- Interop-friendly: pure functions you can call from C# or F#"
      },
      "speakerNotes": "Timing: 3:00 total\n\n0:00–0:15\n- Set context: this is a tiny, realistic registration workflow in F#.\n- Emphasize: plain F#, no advanced FP.\n\n0:15–0:45\n- Show the bullets: states, validation, Result, pattern matching.\n- Transition: \"Let’s look at the code.\"\n\n0:45–1:45 (demo walk-through)\n- Switch to editor.\n- Point out DomainError DU—expected failures as data.\n- Show Email single-case DU with tryCreate; note private constructor and guard against bad input.\n- Highlight Registration DU: Pending vs Confirmed—no third, invalid state.\n- Explain register: pipeline Email.tryCreate -> Pending via Result.map.\n- Explain confirm: pattern match ensures only Pending can become Confirmed; AlreadyConfirmed otherwise.\n\n1:45–2:20 (run it)\n- Switch to terminal or fsi.\n- Paste the example usage (outcome/message).\n- Show message result for a good email.\n- Quickly try a bad email to show InvalidEmail path (optional if time allows).\n\n2:20–2:40 (diagram)\n- Bring up Mermaid flowchart.\n- Trace Ok vs Error paths; underline that every path is modeled and compiler-checked.\n\n2:40–3:00 (wrap)\n- Reinforce: no nulls, no exceptions for normal flow, fewer bugs.\n- Mention interop: these are just .NET types and functions—easy to call from C# or use in ASP.NET Core.\n- Transition to next section.\n\nTechnical reminders\n- Open the .fsx in Ionide or VS; ensure Fantomas formatting.\n- Use dotnet fsi to run quickly.\n- Keep terminal visible during the demo.\n- If typing is slow, paste prepared snippets.\n- Watch for typos in DU case names; the compiler will help if something’s off.",
      "narration": "Let’s model a real business rule in plain F#: a simple registration flow... We’ll keep it practical and readable... No theory, just types that match how the process actually works.\n\nFirst, think about the states... A registration is either Pending or Confirmed... That’s it... In F#, we can express that directly with a discriminated union... We’ll also make Email a dedicated type with a safe constructor so we don’t pass raw strings around and hope for the best... And we’ll use Result to represent expected failures like invalid input or trying to confirm twice, instead of throwing exceptions.\n\nHere’s the idea in code... We define a small DomainError type for the failures we expect: InvalidEmail and AlreadyConfirmed... Email is a single-case union with a private constructor and a tryCreate function that checks the input... If it’s good, we return Ok with a real Email value; if not, we return Error InvalidEmail.\n\nNext, the Registration union says we’re either Pending with an Email, or Confirmed with an Email and a timestamp... There’s no way to create a half-confirmed or null state, because the type doesn’t allow it.\n\nThe register function takes a raw string, tries to turn it into an Email, and if that succeeds, it wraps it into Pending... The confirm function takes the current time and a Registration... If it’s Pending, we return a Confirmed value... If it’s already Confirmed, we return an Error... That’s the rule, encoded in the type system.\n\nLet’s run it quickly... For a good email, we call register and then confirm, piping the result along... We get Ok with a Confirmed value and a timestamp... If we try a bad email, register returns Error InvalidEmail, and the pipeline stops there... No exceptions for normal control flow, and no null checks, because there are no nulls here.\n\nOn the screen, the flowchart shows the same story visually: user enters an email, we validate, we either construct a Pending registration or show a validation message, and when the link is clicked we either confirm or report that it was already confirmed.\n\nWhy this matters for everyday .NET work: invalid states are unrepresentable, failures are explicit, and the compiler helps you handle every case... These are just .NET types and functions, so you can call them from C# or plug them into ASP.NET Core without ceremony.\n\nThat’s records, discriminated unions, and Result working together to model the business, not the plumbing... In the next segment, we’ll build on this and connect it to I/O and the web.",
      "duration": 3,
      "transition": "fade",
      "componentPath": "./components/slides/Slide_s3.tsx",
      "audioPath": "/audio/slide-s3.mp3"
    },
    {
      "id": "s4",
      "content": {
        "type": "markdown",
        "title": "Readable data transformation with the pipe operator and .NET APIs (word count and safer null interop)",
        "markdown": "- Why the pipe (|>) matters: top-to-bottom, readable transformations\n- Works with any .NET API you already use (File, HttpClient, etc.)\n- Convert nulls to Option for safer interop with C#\n- Design functions to take the data last for pipe-friendly code\n\n```fsharp\n// Word count with pipes + .NET APIs\nlet wordCount path =\n    System.IO.File.ReadAllText path\n    |> fun text ->\n        text.Split(\n            [| ' '; '\\n'; '\\t'; '\\r'; '.'; ','; ';'; ':' |],\n            System.StringSplitOptions.RemoveEmptyEntries)\n    |> Array.length\n\n\"README.md\"\n|> wordCount\n|> printfn \"Words: %d\"\n```\n\n```fsharp\n// Safer null interop and headers from HttpClient\nopen System\nopen System.Net.Http\n\nlet safeLength (maybeNull: string) =\n    maybeNull\n    |> Option.ofObj            // null -> None, otherwise Some s\n    |> Option.map String.length\n    |> Option.defaultValue 0\n\nlet tryGetHeader (name: string) (headers: Headers.HttpResponseHeaders) =\n    match headers.TryGetValues name with\n    | true, values -> values |> Seq.tryHead   // string option\n    | _ -> None\n\nlet safeHeader name (resp: HttpResponseMessage) =\n    resp.Headers\n    |> tryGetHeader name\n    |> Option.defaultValue \"<missing>\"\n```\n\n```mermaid\nflowchart TD\n  A[\"File path\"] --> B[\"System.IO.File.ReadAllText\"]\n  B --> C[\"Split by whitespace/punctuation\"]\n  C --> D[\"Array.length\"]\n  D --> E[\"Print 'Words: N'\"]\n  F[\"C# API returns null\"] --> G[\"Option.ofObj\"]\n  G --> H[\"Some value\"] --> I[\"Use safely in pipeline\"]\n  G --> J[\"None\"] --> K[\"Provide default or log\"]\n```"
      },
      "speakerNotes": "Timing: 1.75 minutes total\n\n- 0:00–0:10\n  - Say: We’ll demo readable data transformation with the pipe operator and safer null interop.\n  - Stage: Show slide; point to first bullet.\n\n- 0:10–0:45\n  - Action: Switch to editor. Zoom in on the wordCount function.\n  - Say: Walk top-to-bottom. File.ReadAllText returns a string, pipe into Split, then Array.length.\n  - Technical reminder: Emphasize functions take data last for piping.\n\n- 0:45–1:05\n  - Action: Switch to terminal. Run the script (dotnet fsi demo.fsx) or Alt+Enter in F# Interactive.\n  - Say: Show the printed word count.\n  - Technical reminder: If file not present, change to a local file. Keep it short.\n\n- 1:05–1:35\n  - Action: Back to editor. Highlight safeLength and tryGetHeader.\n  - Say: Explain Option.ofObj for nulls from C#. For headers, TryGetValues returns a bool and values; convert to option and provide a default.\n  - Technical reminder: Mention Option.defaultValue; no exceptions, no null checks scattered around.\n\n- 1:35–1:45\n  - Action: Show Mermaid diagram briefly to reinforce the flow.\n  - Say: Pipes read like a narrative; options make edge cases explicit.\n\n- 1:45–1:50\n  - Close: One-line takeaway—readable pipelines, safer interop, still .NET.\n\n- 1:50–1:55\n  - Prompt: Quick check for questions if time allows.\n\nEnvironment checklist:\n- Have a small text file ready (README.md or sample.txt)\n- Terminal ready with dotnet fsi or F# Interactive pane\n- Ensure internet not required for header demo (no HTTP call needed in run)\n- Zoom cursor for readability",
      "narration": "Let’s look at how F# makes everyday data transformation readable with the pipe operator and still plays nicely with .NET... The pipe, written as vertical bar greater than, passes a value into the next function, so you can read your code top to bottom like a story.\nHere’s a tiny example: a word count... We read the file with the standard .NET API, System.IO.File.ReadAllText... That string flows into Split, which turns it into an array of words, and then into Array.length... The code is idiomatic F#, but it’s calling the same .NET libraries you already use... Because the work is piped step by step, there’s no nesting and it’s easy to tweak or reorder.\nLet’s run it on a local README and print the count... Done... It’s clean, and there’s almost no ceremony.\nNow, a quick safety win when interoperating with C#... If a library might return null, Option.ofObj converts null to None and non-null to Some... From there, Option.map and Option.defaultValue let you handle the value or provide a safe fallback without scattered null checks... The same idea helps with HTTP headers... TryGetValues returns a boolean and a sequence; we turn that into an option with a simple match, then default to a placeholder string if it’s missing.\nThe pattern is consistent: pipe to transform, options to make edge cases explicit... You keep using familiar .NET APIs, but your code reads clearly and avoids common pitfalls... That’s F# for normal people—practical, readable, and safe by default.",
      "duration": 1.75,
      "transition": "fade",
      "componentPath": "./components/slides/Slide_s4.tsx",
      "audioPath": "/audio/slide-s4.mp3"
    },
    {
      "id": "s5",
      "content": {
        "type": "markdown",
        "title": "Async without fuss using task and HttpClient (interop-friendly)",
        "markdown": "**Why task {} for async in F#**\n- task creates real .NET Task values: awaitable in C#, perfect interop\n- Use a single HttpClient instance; add CancellationToken in your API\n- Reads like straightforward imperative code, without callbacks\n- Return Task<'T> so ASP.NET/C# callers can await immediately\n\n```fsharp\nmodule HttpDemo\nopen System\nopen System.Net.Http\nopen System.Text.Json\nopen System.Threading\nopen System.Threading.Tasks\n\nlet http =\n    let c = new HttpClient()\n    c.DefaultRequestHeaders.UserAgent.ParseAdd(\"FSharpDemo/1.0\")\n    c.DefaultRequestHeaders.Accept.ParseAdd(\"application/json\")\n    c\n\nlet fetchStars (repo: string) (ct: CancellationToken) : Task<int> =\n    task {\n        let url = $\"https://api.github.com/repos/%s{repo}\"\n        use! resp = http.GetAsync(url, ct)\n        resp.EnsureSuccessStatusCode()\n        use! stream = resp.Content.ReadAsStreamAsync(ct)\n        let! doc = JsonDocument.ParseAsync(stream, cancellationToken = ct)\n        return doc.RootElement.GetProperty(\"stargazers_count\").GetInt32()\n    }\n\nlet demo ct = task {\n    let! stars = fetchStars \"dotnet/fsharp\" ct\n    return $\"F# repo stars: {stars}\"\n}\n```\n\n```csharp\n// From C# — interop-friendly\nvar stars = await HttpDemo.fetchStars(\"dotnet/fsharp\", ct);\n```\n\n```mermaid\nsequenceDiagram\n  participant User\n  participant FSharp as FSharp task function\n  participant HttpClient\n  participant CSharp as CSharp caller\n  User->>FSharp: fetchStars(repo, ct)\n  FSharp->>HttpClient: GetAsync(url, ct)\n  HttpClient-->>FSharp: HttpResponseMessage\n  FSharp-->>CSharp: Task<int>\n```"
      },
      "speakerNotes": "Timing: 60 seconds total\n0:00–0:10: Set the scene: “Async in F# doesn’t require new mental models. task returns Task, so it’s native to .NET.”\n0:10–0:35: Walk through the code. Point out:\n- task { } block returns Task<int>\n- Reused HttpClient; added User-Agent for GitHub\n- CancellationToken is threaded through GetAsync and ParseAsync\n- EnsureSuccessStatusCode to fail fast\n0:35–0:50: Run demo. Switch to editor/terminal. Execute demo to print stars count. Mention C# interop line briefly.\n0:50–1:00: Wrap: “This is the same HttpClient you already know, just with cleaner syntax. Return Task, accept CancellationToken, you’re interop-ready.”\nStage directions:\n- Switch to editor\n- Zoom into task { } and signature showing Task<int>\n- Open terminal and run (dotnet run or fsi)\n- If network is slow, have output screenshot ready\n- Keep the Mermaid diagram briefly on screen while explaining flow",
      "narration": "Let’s see async in F# without the fuss... In F#, the task computation expression creates real .NET Task values, so everything you write is immediately awaitable from C# and works perfectly with ASP.NET Core... In this example, we reuse a single HttpClient, add a User-Agent header for GitHub, and thread a cancellation token through the call... Inside the task block, the code reads like straightforward imperative code: we await GetAsync, ensure success, read the stream, parse the JSON, and return the stargazer count as an int... The function signature returns Task of int, so C sharp can simply await it... Here’s the interop story in one line: await HttpDemo.fetchStars with a repo and a cancellation token... No wrappers, no adapters... This is just .NET... The win is cleaner syntax, strong typing, and easy cancellation, while keeping the same HttpClient you already know... That’s async in F#, interop-friendly and simple enough to use today.",
      "duration": 1,
      "transition": "fade",
      "componentPath": "./components/slides/Slide_s5.tsx",
      "audioPath": "/audio/slide-s5.mp3"
    },
    {
      "id": "s6",
      "content": {
        "type": "markdown",
        "title": ".NET interop and tooling snapshot: libraries, ASP.NET Core, Ionide/VS, Fantomas, Functions",
        "markdown": "- Full .NET interop: call System.Text.Json, HttpClient, EF/Dapper, Serilog; return Task for C# callers; runs on Windows/Mac/Linux\n- ASP.NET Core: minimal APIs or Giraffe; deploy like any .NET service or container\n- Tooling: VS Code + Ionide or Visual Studio; format with Fantomas; build/test with dotnet CLI\n- Serverless: Azure Functions isolated worker pairs well with task { } and immutable records\n```fsharp\n// Minimal API (ASP.NET Core) + JSON interop\nopen System\nopen System.Text.Json\nopen Microsoft.AspNetCore.Builder\n\ntype Todo = { id:int; title:string }\nlet builder = WebApplication.CreateBuilder()\nlet app = builder.Build()\napp.MapGet(\"/todo\", Func<Todo>(fun () -> { id=1; title=\"Learn F#\" })) |> ignore\nlet json = JsonSerializer.Serialize { id=1; title=\"Learn F#\" }\napp.Run()\n```\n```fsharp\n// Azure Functions (isolated)\nmodule Functions\nopen Microsoft.Azure.Functions.Worker\nopen Microsoft.Azure.Functions.Worker.Http\nopen System.Net\n\n[<Function(\"Ping\")>]\nlet run([<HttpTrigger(AuthorizationLevel.Anonymous, \"get\", Route = \"ping\")>] req: HttpRequestData) =\n  task {\n    let res = req.CreateResponse(HttpStatusCode.OK)\n    do! res.WriteStringAsync \"pong\"\n    return res\n  }\n```\n```mermaid\nflowchart LR\nFSharp[\"F# code\"] --> Libs[\".NET libraries\"]\nLibs --> Api[\"ASP.NET Core service\"]\nLibs --> Fx[\"Azure Functions (isolated)\"]\nLibs --> Cli[\"Console/CLI & containers\"]\nTooling[\"Ionide/VS + Fantomas\"] --> FSharp\n```\n"
      },
      "speakerNotes": "Spend ~10 seconds highlighting the four bullets: emphasize “F# is just .NET,” Task interop, and Fantomas.\nPoint to the minimal API snippet for ~10 seconds: note record + System.Text.Json + MapGet returning a record.\nBriefly show the Azure Functions snippet for ~8–10 seconds: call out isolated worker + task.\nRemind yourself to tie back to practicality: same deployment, same DevOps.\nNo deep dives here—keep momentum and transition to the next section.",
      "narration": "Here’s the quick interop and tooling snapshot... F# is just .NET, so you call System.Text.Json, HttpClient, EF or Dapper, and you return Task so C# callers are happy... For web, you can use ASP.NET Core minimal APIs or Giraffe and deploy like any other .NET service or container... On tools, use VS Code with Ionide or Visual Studio; Fantomas keeps formatting consistent, and everything runs through the dotnet CLI... For serverless, the Azure Functions isolated worker fits naturally with task workflows and immutable records.",
      "duration": 0.5,
      "transition": "fade",
      "componentPath": "./components/slides/Slide_s6.tsx",
      "audioPath": "/audio/slide-s6.mp3"
    },
    {
      "id": "s7",
      "content": {
        "type": "markdown",
        "title": "How to start today and where F# shines: APIs, ETL, cloud functions — key takeaways",
        "markdown": "- Start small: records, DUs, Option/Result, and the pipe (|>)—you don’t need advanced FP\n- Where it shines: small APIs, ETL/data wrangling, and cloud/serverless functions\n- Interop is seamless: use any .NET library, return Task, serialize records with System.Text.Json\n- Functional core, imperative shell: pure logic in the middle, I/O at the edges\n- Ship like normal .NET: dotnet CLI, containers, CI/CD, Azure/AWS/GCP\n\n```fsharp\n// Lean API handler using records, DU validation, and Result -> HTTP\nopen System\nopen Microsoft.AspNetCore.Http\n\ntype Email = private Email of string\nmodule Email =\n  let tryCreate s =\n    if String.IsNullOrWhiteSpace s || not (s.Contains \"@\") then Error \"Invalid email\"\n    else Ok (Email s)\n\nlet subscribe (email:string) : IResult =\n  email.Trim().ToLowerInvariant()\n  |> Email.tryCreate\n  |> function\n     | Ok _ -> Results.NoContent()\n     | Error e -> Results.BadRequest(e)\n```\n\n```fsharp\n// ETL: strongly-typed CSV with a tiny script\nopen FSharp.Data\n\ntype Sales = CsvProvider<\"date,amount\\n2024-01-01,42.50\">\nlet total path =\n  let csv = Sales.Load(path)\n  csv.Rows |> Seq.sumBy (fun r -> r.Amount) |> printfn \"Total: %M\"\n```\n\n```fsharp\n// Cloud function (Azure Functions isolated worker)\nopen System.Net\nopen Microsoft.Azure.Functions.Worker\nopen Microsoft.Azure.Functions.Worker.Http\n\ntype Functions() =\n  [<Function(\"Ping\")>]\n  member _.Ping([<HttpTrigger(AuthorizationLevel.Anonymous, \"get\", Route = \"ping\")>] req: HttpRequestData) =\n    task {\n      let res = req.CreateResponse(HttpStatusCode.OK)\n      res.WriteString(\"pong\")\n      return res\n    }\n```\n\n```mermaid\nflowchart TD\nA[\"Pick one small use case\"] --> B[\"Model with records + DUs\"]\nB --> C[\"Handle with Option/Result + pattern match\"]\nC --> D[\"Pipe transformations (|>)\"]\nD --> E[\"Deploy as API / ETL / Function\"]\n```"
      },
      "speakerNotes": "- 0:00 Switch to conclusion slide; quick energy lift\n- 0:00–0:20 Summarize: F# makes everyday tasks simpler—immutability, type inference, and pattern matching reduce bugs\n- 0:20–0:35 Call out where it shines: APIs, ETL, and cloud/serverless; emphasize small, focused services\n- 0:35–1:05 How to start today (step-by-step):\n  - Install Ionide or use Visual Studio; ensure .NET SDK\n  - dotnet new console -lang F# or minimal API template\n  - Model with records + DUs; use Option/Result; design for |> pipes\n  - Keep pure logic separate; return Task at boundaries for interop\n  - Deploy like any .NET app (container or Functions)\n- 1:05–1:20 Walk the code snippets on screen: point at the DU validation, the CSV provider, and the task-based Azure Function\n- 1:20–1:25 Reinforce interop: same .NET libraries, same DevOps\n- 1:25–1:30 CTA: pick one small API/ETL/Function to build in F# this week\n- Technical reminders: don’t dive into advanced features; mention Fantomas; note System.Text.Json works with records\n- No live demo here—just reference the snippets; keep pace brisk; smile and thank the audience",
      "narration": "Let’s land this with the simplest next step and the places where F# really shines... If you remember one thing, it’s this: you can be productive in F# today without advanced functional theory... Start small with records and discriminated unions, handle errors with Option and Result, and use the pipe operator to keep code readable.\n\nThree sweet spots to try right away... First, small web APIs: model your requests and responses as records and DUs, validate with Result, and return Task so C# and ASP.NET Core are happy... Second, ETL and data wrangling: F# scripts plus type providers give you strongly typed CSV and JSON with almost no boilerplate, and piping makes transformations read top to bottom... Third, cloud functions: the Azure Functions isolated worker fits F# nicely—task workflows, tiny handlers, quick deployments.\n\nHow to start this week... Install Ionide for VS Code or use Visual Studio, run dotnet new with the F# language, and model one endpoint or one job with records and DUs... Convert nulls at the boundary into Option, keep pure logic in the middle, and do I/O at the edges... Serialize records with System.Text.Json, and deploy like any other .NET app—containers, CI/CD, Azure, AWS, or GCP.\n\nBottom line: it’s just .NET, with safer models and less ceremony... Pick one small API, ETL task, or function, build it in F#, and feel the difference... Thanks for joining, and happy shipping!",
      "duration": 1.5,
      "transition": "fade",
      "voice": {
        "emotion": "friendly",
        "pace": "slow"
      },
      "componentPath": "./components/slides/Slide_s7.tsx",
      "audioPath": "/audio/slide-s7.mp3"
    }
  ],
  "transitions": {
    "default": "fade",
    "duration": 500
  }
}
